正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。
# 创建一个正则表达式
* 正则表达式字面量

使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：
```js
var re = /ab+c/;
```
使用正则表达式字面量为正则表达式提供了脚本加载后的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。


* 调用RegExp对象的构造函数  
调用RegExp对象的构造函数，如下所示：
```js
var re = new RegExp("ab+c");
```
使用构造函数为正则表达式提供了运行时的编译。使用构造函数的方式，当你知道正则表达式的模式将会改变，或者你不知道模式，并且从其他来源获取它，如用户输入。
# 编写一个正则表达式的模式
一个正则表达式模式是由简单的字符所构成的，比如 /abc/；或者是简单和特殊字符的组合，比如 /ab\*c/ 或 /Chapter (\d+)\\.\d*/。最后的例子中用到了括号，它在正则表达式中常用作记忆设备。即这部分所匹配的字符将会被记住以备后续使用
## 使用简单模式
简单模式是由你想直接找到的字符构成。比如，/abc/ 这个模式就能且仅能匹配 "abc" 字符按照顺序同时出现的情况。例如在 "Hi, do you know your abc's?" 和 "The latest airplane designs evolved from slabcraft." 中会匹配成功。在上述两个例子中，匹配的子字符串是 "abc"。但是在 "Grab crab" 中会匹配失败，因为它虽然包含子字符串 "ab c"，但并不是准确的 "abc"。
## 使用特殊字符
当你需要搜索一个比直接匹配需要更多条件的匹配时，比如寻找一个或多个 "b"，或者寻找空格，这时可以在模式中使用特殊字符。比如，你可以使用 /ab\*c/ 去匹配一个单独的 "a" 后面跟了零个或者多个 "b"，同时后面跟着 "c" 的字符串：*的意思是前一项出现零次或者多次。在字符串 "cbbabbbbcdebc" 中，这个模式匹配了子字符串 "abbbbc"。
# 正则表达式中的特殊字符

|字符|含义|
| - | - |
|`\`| 依照下列规则匹配:<br/><br/>在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 "\\" 的 "b" 通常匹配小写字母 "b"，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 "\\"，它将不再匹配任何字符，而是表示一个字符边界。<br/><br/>在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解<br/><br/>如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。/[a-z]\s/i 和 new RegExp("[a-z]\\\s", "i") 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\s 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和表达式级别都对它进行转义。例如 /[a-z]:\\/i 和 new RegExp("[a-z]:\\\\\\\\","i") 会创建相同的表达式，即匹配类似 "C:\" 字符串。|  
|`^`|匹配输入的开始。<br/><br/>如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置<br/>例如，/^A/ 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'。<br/><br/>当 '^' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合 一节有详细介绍和示例。|
|`*`|匹配前一个表达式 0 次或多次。等价于 {0,}。<br/>例如，/bo*/ 会匹配 "A ghost boooooed" 中的 'booooo' 和 "A bird warbled" 中的 'b'，但是在 "A goat grunted" 中不会匹配任何内容。|
|`+`|匹配前面一个表达式 1 次或者多次。等价于 {1,}。<br/>例如，/a+/ 会匹配 "candy" 中的 'a' 和 "caaaaaaandy" 中所有的 'a'，但是在 "cndy" 中不会匹配任何内容。|
|`(x)`|像下面的例子展示的那样，它会匹配 'x' 并且记住匹配项。其中括号被称为捕获括号<br/>模式 /(foo) (bar) \1 \2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 \1 和 \2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，匹配了原字符串中的后两个单词。注意 \1、\2、...、\n 是用在正则表达式的匹配环节，详情可以参阅后文的 \n 条目。而在正则表达式的替换环节，则要使用像 $1、$2、...、$n 这样的语法，例如，'bar foo'.replace(/(...) (...)/, '$2 $1')。$& 表示整个用于匹配的原字符串。|
|`(?:x)`|匹配 'x' 但是不记住匹配项。<br/>这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2} 将只应用于 'foo' 的最后一个字符 'o'。如果使用非捕获括号，则 {1,2} 会应用于整个 'foo' 单词。更多信息，可以参阅下文的 Using parentheses 条目.|
|`x|y`|匹配‘x’或者‘y’。<br/>例如，/green\|red/匹配“green apple”中的‘green’和“red apple”中的‘red’|
|`[^abc]`|一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。<br/>例如，[^abc] 和 [^a-c] 是一样的。他们匹配"brisket"中的‘r’，也匹配“chop”中的‘h’。|
|`[\b]`|匹配一个退格(U+0008)。（不要和\b混淆了。）|
|`\s`|匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。<br/>例如, /\s\w*/ 匹配"foo bar."中的' bar'。|
|`\w`|匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。<br/>例如, /\w/ 匹配 "apple," 中的 'a'，"$5.28,"中的 '5' 和 "3D." 中的 '3'。|
|`\W`|匹配一个非单字字符。等价于 [^A-Za-z0-9_]。<br/>例如, /\W/ 或者 /[^A-Za-z0-9_]/ 匹配 "50%." 中的 '%'。|
|`\xhh`|与代码 hh 匹配字符（两个十六进制数字）|
# 使用正则表达式
正则表达式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。
## 使用正则表达式的方法
|方法|描述|
|-|-|
|`exec`|一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。|